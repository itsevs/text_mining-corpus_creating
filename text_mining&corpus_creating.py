# -*- coding: utf-8 -*-
"""text_mining&corpus_creating.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bSSbN0VxADUg4HjaR_D8Wx6bjUvHzymw
"""

# URL_TO_HTML-TEXT
 
import urllib.request    
 
urls = ['https://en.wikipedia.org/wiki/Dancing_plague_of_1518', 'https://en.wikipedia.org/wiki/Infinite_monkey_theorem', 'https://en.wikipedia.org/wiki/Tetris_effect', 'https://en.wikipedia.org/wiki/Time_flies_like_an_arrow;_fruit_flies_like_a_banana', 'https://en.wikipedia.org/wiki/Jazz_standard', 'https://en.wikipedia.org/wiki/Extreme_ironing', 'https://en.wikipedia.org/wiki/Flamenco', 'https://en.wikipedia.org/wiki/Erd%C5%91s_number', 'https://en.wikipedia.org/wiki/Cocido_madrile%C3%B1o', 'https://en.wikipedia.org/wiki/Lasagne']
docs = []
for i in range(len(urls)):
  # stores HTML code of urls[i] in text file 'text[i].txt'
  url = urls[i]
  text_file = 'html' + str(i) + '.txt'
  urllib.request.urlretrieve(url, text_file) # this creates a .txt document with the HTML source, named html[i].txt
  # create a list of directions of the html txt files
  docs.append('/content/' + urllib.request.urlretrieve(url, text_file)[0])

# BS4

# pip install beautifulsoup4
from bs4 import BeautifulSoup
texts_dirs = []
for i in range(len(docs)): # cleaning each HTML document
  current = docs[i]
  with open(current) as doc:
    soup = BeautifulSoup(doc, "html.parser")

  title = soup.head.title.text # returns title inside <head>
  paragraphs = soup.find_all("p") # returns a list of elements inside tags containing 'p'

  file_name = 'text' + str(i) + '.txt' # creating new text file with cleaned text
  f = open(file_name, "w+")
  f.write(title + ' ')
  for p in range(len(paragraphs)): # for every paragraph gets the plain text without tags
    f.write(paragraphs[p].get_text())
  # create a list of directions of the text files
  texts_dirs.append('/content/' + file_name)
  f.close()

# NL Text Processing

import nltk
#nltk.download() # select d (download) + all
from nltk.tokenize import sent_tokenize, word_tokenize
import string

relevant_words = []
for i in range(len(texts_dirs)):
  current = texts_dirs[i]
  with open(current) as doc:
    tokens = word_tokenize(doc.read())
    pos_tags = nltk.pos_tag(tokens)
    less_pos_tags = pos_tags.copy() # copy tags list so that we can edit it
    k = 0 # counter to remove items appropiately
    delete_str = 'DT IN CC TO CD' + string.punctuation + '`` '' "'
    for i in range(len(pos_tags)-1):
      if pos_tags[i][1] in delete_str:
        less_pos_tags.pop(i-k)
        k = k + 1
    relevant_words_here = [i[0] for i in less_pos_tags]
    # relevant_words is a list of list
    # each list contains the relevant words of a document, given by relevant_words_here
    relevant_words.append(relevant_words_here)
    # relevant_words[0] gives the relevant words of the first document, etc

# Remove stop-words

#nltk.download('stopwords')
from nltk.corpus import stopwords

stop_words = stopwords.words('english')

filtered_relevant_words = []
for set in relevant_words:
  for word in set:
    if word not in stop_words:
      filtered_relevant_words.append(word)

# create vocabulary with the filtered relevant words
f = open('vocabulary.txt', "w+")
for w in filtered_relevant_words:
  f.write(w + ' ')
f.close()
# we've created a txt document containing the vocabulary of all documents, with repeated and not truncated words

#@title 
# PORTER'S STEMMING ALGORITHM

import sys

class PorterStemmer:

    def __init__(self):
        """The main part of the stemming algorithm starts here.
        b is a buffer holding a word to be stemmed. The letters are in b[k0],
        b[k0+1] ... ending at b[k]. In fact k0 = 0 in this demo program. k is
        readjusted downwards as the stemming progresses. Zero termination is
        not in fact used in the algorithm.

        Note that only lower case sequences are stemmed. Forcing to lower case
        should be done before stem(...) is called.
        """

        self.b = ""  # buffer for word to be stemmed
        self.k = 0
        self.k0 = 0
        self.j = 0   # j is a general offset into the string

    def cons(self, i):
        """cons(i) is TRUE <=> b[i] is a consonant."""
        if self.b[i] == 'a' or self.b[i] == 'e' or self.b[i] == 'i' or self.b[i] == 'o' or self.b[i] == 'u':
            return 0
        if self.b[i] == 'y':
            if i == self.k0:
                return 1
            else:
                return (not self.cons(i - 1))
        return 1

    def m(self):
        """m() measures the number of consonant sequences between k0 and j.
        if c is a consonant sequence and v a vowel sequence, and <..>
        indicates arbitrary presence,

           <c><v>       gives 0
           <c>vc<v>     gives 1
           <c>vcvc<v>   gives 2
           <c>vcvcvc<v> gives 3
           ....
        """
        n = 0
        i = self.k0
        while 1:
            if i > self.j:
                return n
            if not self.cons(i):
                break
            i = i + 1
        i = i + 1
        while 1:
            while 1:
                if i > self.j:
                    return n
                if self.cons(i):
                    break
                i = i + 1
            i = i + 1
            n = n + 1
            while 1:
                if i > self.j:
                    return n
                if not self.cons(i):
                    break
                i = i + 1
            i = i + 1

    def vowelinstem(self):
        """vowelinstem() is TRUE <=> k0,...j contains a vowel"""
        for i in range(self.k0, self.j + 1):
            if not self.cons(i):
                return 1
        return 0

    def doublec(self, j):
        """doublec(j) is TRUE <=> j,(j-1) contain a double consonant."""
        if j < (self.k0 + 1):
            return 0
        if (self.b[j] != self.b[j-1]):
            return 0
        return self.cons(j)

    def cvc(self, i):
        """cvc(i) is TRUE <=> i-2,i-1,i has the form consonant - vowel - consonant
        and also if the second c is not w,x or y. this is used when trying to
        restore an e at the end of a short  e.g.

           cav(e), lov(e), hop(e), crim(e), but
           snow, box, tray.
        """
        if i < (self.k0 + 2) or not self.cons(i) or self.cons(i-1) or not self.cons(i-2):
            return 0
        ch = self.b[i]
        if ch == 'w' or ch == 'x' or ch == 'y':
            return 0
        return 1

    def ends(self, s):
        """ends(s) is TRUE <=> k0,...k ends with the string s."""
        length = len(s)
        if s[length - 1] != self.b[self.k]: # tiny speed-up
            return 0
        if length > (self.k - self.k0 + 1):
            return 0
        if self.b[self.k-length+1:self.k+1] != s:
            return 0
        self.j = self.k - length
        return 1

    def setto(self, s):
        """setto(s) sets (j+1),...k to the characters in the string s, readjusting k."""
        length = len(s)
        self.b = self.b[:self.j+1] + s + self.b[self.j+length+1:]
        self.k = self.j + length

    def r(self, s):
        """r(s) is used further down."""
        if self.m() > 0:
            self.setto(s)

    def step1ab(self):
        """step1ab() gets rid of plurals and -ed or -ing. e.g.

           caresses  ->  caress
           ponies    ->  poni
           ties      ->  ti
           caress    ->  caress
           cats      ->  cat

           feed      ->  feed
           agreed    ->  agree
           disabled  ->  disable

           matting   ->  mat
           mating    ->  mate
           meeting   ->  meet
           milling   ->  mill
           messing   ->  mess

           meetings  ->  meet
        """
        if self.b[self.k] == 's':
            if self.ends("sses"):
                self.k = self.k - 2
            elif self.ends("ies"):
                self.setto("i")
            elif self.b[self.k - 1] != 's':
                self.k = self.k - 1
        if self.ends("eed"):
            if self.m() > 0:
                self.k = self.k - 1
        elif (self.ends("ed") or self.ends("ing")) and self.vowelinstem():
            self.k = self.j
            if self.ends("at"):   self.setto("ate")
            elif self.ends("bl"): self.setto("ble")
            elif self.ends("iz"): self.setto("ize")
            elif self.doublec(self.k):
                self.k = self.k - 1
                ch = self.b[self.k]
                if ch == 'l' or ch == 's' or ch == 'z':
                    self.k = self.k + 1
            elif (self.m() == 1 and self.cvc(self.k)):
                self.setto("e")

    def step1c(self):
        """step1c() turns terminal y to i when there is another vowel in the stem."""
        if (self.ends("y") and self.vowelinstem()):
            self.b = self.b[:self.k] + 'i' + self.b[self.k+1:]

    def step2(self):
        """step2() maps double suffices to single ones.
        so -ization ( = -ize plus -ation) maps to -ize etc. note that the
        string before the suffix must give m() > 0.
        """
        if self.b[self.k - 1] == 'a':
            if self.ends("ational"):   self.r("ate")
            elif self.ends("tional"):  self.r("tion")
        elif self.b[self.k - 1] == 'c':
            if self.ends("enci"):      self.r("ence")
            elif self.ends("anci"):    self.r("ance")
        elif self.b[self.k - 1] == 'e':
            if self.ends("izer"):      self.r("ize")
        elif self.b[self.k - 1] == 'l':
            if self.ends("bli"):       self.r("ble") # --DEPARTURE--
            # To match the published algorithm, replace this phrase with
            #   if self.ends("abli"):      self.r("able")
            elif self.ends("alli"):    self.r("al")
            elif self.ends("entli"):   self.r("ent")
            elif self.ends("eli"):     self.r("e")
            elif self.ends("ousli"):   self.r("ous")
        elif self.b[self.k - 1] == 'o':
            if self.ends("ization"):   self.r("ize")
            elif self.ends("ation"):   self.r("ate")
            elif self.ends("ator"):    self.r("ate")
        elif self.b[self.k - 1] == 's':
            if self.ends("alism"):     self.r("al")
            elif self.ends("iveness"): self.r("ive")
            elif self.ends("fulness"): self.r("ful")
            elif self.ends("ousness"): self.r("ous")
        elif self.b[self.k - 1] == 't':
            if self.ends("aliti"):     self.r("al")
            elif self.ends("iviti"):   self.r("ive")
            elif self.ends("biliti"):  self.r("ble")
        elif self.b[self.k - 1] == 'g': # --DEPARTURE--
            if self.ends("logi"):      self.r("log")
        # To match the published algorithm, delete this phrase

    def step3(self):
        """step3() dels with -ic-, -full, -ness etc. similar strategy to step2."""
        if self.b[self.k] == 'e':
            if self.ends("icate"):     self.r("ic")
            elif self.ends("ative"):   self.r("")
            elif self.ends("alize"):   self.r("al")
        elif self.b[self.k] == 'i':
            if self.ends("iciti"):     self.r("ic")
        elif self.b[self.k] == 'l':
            if self.ends("ical"):      self.r("ic")
            elif self.ends("ful"):     self.r("")
        elif self.b[self.k] == 's':
            if self.ends("ness"):      self.r("")

    def step4(self):
        """step4() takes off -ant, -ence etc., in context <c>vcvc<v>."""
        if self.b[self.k - 1] == 'a':
            if self.ends("al"): pass
            else: return
        elif self.b[self.k - 1] == 'c':
            if self.ends("ance"): pass
            elif self.ends("ence"): pass
            else: return
        elif self.b[self.k - 1] == 'e':
            if self.ends("er"): pass
            else: return
        elif self.b[self.k - 1] == 'i':
            if self.ends("ic"): pass
            else: return
        elif self.b[self.k - 1] == 'l':
            if self.ends("able"): pass
            elif self.ends("ible"): pass
            else: return
        elif self.b[self.k - 1] == 'n':
            if self.ends("ant"): pass
            elif self.ends("ement"): pass
            elif self.ends("ment"): pass
            elif self.ends("ent"): pass
            else: return
        elif self.b[self.k - 1] == 'o':
            if self.ends("ion") and (self.b[self.j] == 's' or self.b[self.j] == 't'): pass
            elif self.ends("ou"): pass
            # takes care of -ous
            else: return
        elif self.b[self.k - 1] == 's':
            if self.ends("ism"): pass
            else: return
        elif self.b[self.k - 1] == 't':
            if self.ends("ate"): pass
            elif self.ends("iti"): pass
            else: return
        elif self.b[self.k - 1] == 'u':
            if self.ends("ous"): pass
            else: return
        elif self.b[self.k - 1] == 'v':
            if self.ends("ive"): pass
            else: return
        elif self.b[self.k - 1] == 'z':
            if self.ends("ize"): pass
            else: return
        else:
            return
        if self.m() > 1:
            self.k = self.j

    def step5(self):
        """step5() removes a final -e if m() > 1, and changes -ll to -l if
        m() > 1.
        """
        self.j = self.k
        if self.b[self.k] == 'e':
            a = self.m()
            if a > 1 or (a == 1 and not self.cvc(self.k-1)):
                self.k = self.k - 1
        if self.b[self.k] == 'l' and self.doublec(self.k) and self.m() > 1:
            self.k = self.k -1

    def stem(self, p, i, j):
        """In stem(p,i,j), p is a char pointer, and the string to be stemmed
        is from p[i] to p[j] inclusive. Typically i is zero and j is the
        offset to the last character of a string, (p[j+1] == '\0'). The
        stemmer adjusts the characters p[i] ... p[j] and returns the new
        end-point of the string, k. Stemming never increases word length, so
        i <= k <= j. To turn the stemmer into a module, declare 'stem' as
        extern, and delete the remainder of this file.
        """
        # copy the parameters into statics
        self.b = p
        self.k = j
        self.k0 = i
        if self.k <= self.k0 + 1:
            return self.b # --DEPARTURE--

        # With this line, strings of length 1 or 2 don't go through the
        # stemming process, although no mention is made of this in the
        # published algorithm. Remove the line to match the published
        # algorithm.

        self.step1ab()
        self.step1c()
        self.step2()
        self.step3()
        self.step4()
        self.step5()
        return self.b[self.k0:self.k+1]

# Stemming

p = PorterStemmer()
stemmed_words = [p.stem(k,0,len(k)-1) for k in filtered_relevant_words]

# Elimination of repeated words

lower_cased = [i.lower() for i in stemmed_words]
final_vocabulary = list(dict.fromkeys(lower_cased))
# create a .txt for the final vocabulary
f = open('final_vocabulary.txt', "w+")
for w in final_vocabulary:
  f.write(w + ' ')
f.close()
# vocabulary containing all words appearing in the documents, stemmed and with no repetitions

# Weight functions

# Local weight function : Term Frequency (TF)

f1 = open('local_term_frequencies.txt', 'w+')
term_frequencies = [] # this will be a list of lists, containing tf for each document, useful for creating the inverse document
for i in range(len(texts_dirs)):
  current = texts_dirs[i]
  with open(current) as doc:
    splitted = list(doc.read().split())
    lowered = [i.lower() for i in splitted]
    p = PorterStemmer()
    text = [p.stem(k,0,len(k)-1) for k in lowered] # list of words of the current text, lowercased and stemmed
    count_dic_text = {i:text.count(i) for i in final_vocabulary} # dictionary containing all words of the vocabulary
                                                                # and number of occurrences in current document
    term_frequencies_doc = [] # list containing tf of current document
    n = len(text) # number of words in the given text
    for word in final_vocabulary:
      term_frequencies_doc.append(count_dic_text[word]/float(n))
    term_frequencies.append(term_frequencies_doc)
    for tf in term_frequencies_doc:
      f1.write(str(tf) + ' ')
    f1.write('\n')
f1.close()

# Inversed document

'''
For each word of the vocabulary, specifies frequency relative to each document
'''

f2 = open('fichero_invertido.txt', 'w+')
inversed = [[str(i) + ':'] for i in final_vocabulary]
for i in range(len(final_vocabulary)):
  for j in range(len(term_frequencies)):
    inversed[i].append('doc' + str(j) + '=' + str(term_frequencies[j][i]))
  f2.write(str(inversed[i]) + '\n')
f2.close()

# Global frequencies

# First: For each word of the vocabulary, number of documents that contain it (DF)
N = len(urls)
df = []
for j in range(len(final_vocabulary)):
  count = 0
  for i in range(len(term_frequencies)):
    if term_frequencies[i][j] != 0:
      count = count + 1
  df.append(count)

# Inverse document frequencies (IDF)
import math

idf = [math.log(N/(1 + df[i])) for i in range(len(final_vocabulary))]

#TFIDF

f3 = open('tfidfs.txt', 'w+')
for i in range(len(term_frequencies)):
  for j in range(len(final_vocabulary)):
    f3.write(str(term_frequencies[i][j]*idf[j]) + ' ')
  f3.write('\n')